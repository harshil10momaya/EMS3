import os
import subprocess
import glob
import sys

# --- Configuration ---
# Set the desired version and motif parameters for testing
# Note: L=11, D=3 matches the synthetic planted_l11_d3.txt case generated by default.
TEST_VERSION = "2p" # Test the parallel version (2p)
TEST_L = 11        # Motif Length
TEST_D = 3         # Edit Distance
TEST_THREADS = 4   # Number of processes for parallel version

# Path to the main executable (relative to this script's location in 'test' folder)
MAIN_APP_PATH = os.path.join(os.path.dirname(__file__), '..', 'src', 'main.py')
GENERATOR_SCRIPT = os.path.join(os.path.dirname(__file__), 'generate_cases.py')

def run_command(command: list, description: str):
    """Executes a shell command and prints the output."""
    print(f"\n--- Running: {description} ---")
    
    try:
        # We execute python explicitly on the script file
        result = subprocess.run(
            [sys.executable] + command, 
            capture_output=True, 
            text=True, 
            check=True,
            # Set CWD to src directory for main.py execution if necessary, 
            # but usually script paths handle this.
            # We'll rely on the full path in 'command' for simplicity.
        )
        print("COMMAND OUTPUT:\n" + result.stdout)
        
    except subprocess.CalledProcessError as e:
        print(f"\n!!! ERROR running {description} !!!", file=sys.stderr)
        print(f"Command: {' '.join(command)}", file=sys.stderr)
        print("STDERR:\n" + e.stderr, file=sys.stderr)
    except FileNotFoundError:
        print(f"Error: Python executable or script file not found.", file=sys.stderr)

def main():
    print("===============================================")
    print(f"Motif Search Test Runner Setup:")
    print(f"Version: {TEST_VERSION}, L={TEST_L}, D={TEST_D}, Threads={TEST_THREADS}")
    print("===============================================")

    # 1. Run the case generator script (it generates planted_l11_d3.txt locally)
    run_command([GENERATOR_SCRIPT], "Generating Synthetic Test Case")
    
    # 2. Find all input files in the current directory
    test_dir = os.path.dirname(__file__)
    test_files = [f for f in glob.glob(os.path.join(test_dir, "*.txt"))]
    
    if not test_files:
        print("No .txt test files found in the 'test' directory.")
        return

    print(f"\nFound {len(test_files)} input files. Starting search tests...\n")
    
    # 3. Execute main.py for each input file
    for test_file in test_files:
        filename = os.path.basename(test_file)
        
        # Determine L and D from filename if it follows the l#_d# pattern
        # This allows testing the 'golden' and 'planted' files with their native parameters
        current_l = TEST_L
        current_d = TEST_D
        try:
            parts = filename.split('_')
            l_part = next(p for p in parts if p.startswith('l') and p[1:].isdigit())
            d_part = next(p for p in parts if p.startswith('d') and p[1:].isdigit())
            
            if l_part and d_part:
                current_l = int(l_part[1:])
                current_d = int(d_part[1:])
        except:
             # If L/D cannot be parsed from filename, use default TEST_L/D
             pass


        # Build the command: python src/main.py -s [VERSION] -l [L] -d [D] -t [THREADS] [FILE]
        command = [
            MAIN_APP_PATH, 
            '-s', TEST_VERSION, 
            '-l', str(current_l), 
            '-d', str(current_d), 
            '-t', str(TEST_THREADS),
            test_file # Pass the full path to the test file
        ]
        
        run_command(command, f"Running {TEST_VERSION} on {filename} (L={current_l}, D={current_d})")
        
    print("\n===============================================")
    print("Testing complete. Check the generated 'out_*.txt' files in the 'test' directory.")
    print("===============================================")

if __name__ == "__main__":
    main()